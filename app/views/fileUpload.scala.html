@import models.User
@import services.{FileProcessResult, MultiFileUploadResult}
@import models.StarCraftModels._
@import services.UploadSession
@import models.{Tournament, TournamentMatch}
@(user: User, tournamentID: Long, matchID: Long, uploadSession: UploadSession, errorMessage: Option[String] = None, tournament: Option[Tournament] = None, tournamentMatch: Option[TournamentMatch] = None, firstUser: Option[User] = None, secondUser: Option[User] = None)(implicit request: RequestHeader, flash: Flash, messages: Messages)

@main(messages("upload.title"), Some(user)) {
<div id="file-upload-container">
    <header>
        <h1>@messages("upload.title")</h1>
        @if(tournament.isDefined && tournamentMatch.isDefined && firstUser.isDefined && secondUser.isDefined) {
        <div class="match-info">
            <h2>@tournament.get.name</h2>
            <p class="match-details">
                <strong>@messages("upload.match.title"):</strong> @firstUser.get.userName @messages("upload.vs")
                @secondUser.get.userName
            </p>
            <div class="match-metadata" style="display: none;">
                <span id="tournament-id">@tournament.get.id</span>
                <span id="match-id">@tournamentMatch.get.matchId</span>
            </div>
        </div>
        }
        <p>@messages("upload.subtitle")</p>
    </header>

    @if(uploadSession.hasFiles && tournament.isDefined && tournamentMatch.isDefined && firstUser.isDefined &&
    secondUser.isDefined) {
    <!-- Status Section -->
    <section>
        <article>
            <header>
                <h3>@messages("upload.session.status")</h3>
            </header>
            <p>@messages("upload.processing.completed", uploadSession.totalFiles.toString)</p>

            @if(uploadSession.successfulFiles.nonEmpty) {
            <details open>
                <summary>@messages("upload.successfully.processed", uploadSession.successfulFiles.length.toString)
                </summary>
                <div class="table-container">
                    <table>
                        <thead>
                        <tr>
                            <th>@messages("upload.table.map")</th>
                            <th>@messages("upload.table.player1")</th>
                            <th>@messages("upload.table.player2")</th>
                            <th>@messages("upload.table.start.time")</th>
                        </tr>
                        </thead>
                        <tbody>
                        @for(file <- uploadSession.successfulFiles) {
                        <tr>
                            @file.gameInfo match {
                            case Some(replayParsed: ReplayParsed) => {
                            <td>@replayParsed.mapName.getOrElse("Unknown")</td>
                            <td>
                                @if(replayParsed.teams.nonEmpty && replayParsed.teams.head.participants.nonEmpty) {
                                @defining(replayParsed.teams.head.participants.head) { player =>
                                @player.name (@{
                                player.race match {
                                case Zerg => "Z"
                                case Terran => "T"
                                case Protoss => "P"
                                }
                                })
                                }
                                } else {
                                @messages("upload.unknown.player")
                                }
                            </td>
                            <td>
                                @if(replayParsed.teams.length > 1 && replayParsed.teams(1).participants.nonEmpty) {
                                @defining(replayParsed.teams(1).participants.head) { player =>
                                @player.name (@{
                                player.race match {
                                case Zerg => "Z"
                                case Terran => "T"
                                case Protoss => "P"
                                }
                                })
                                }
                                } else {
                                @messages("upload.unknown.player")
                                }
                            </td>
                            <td>
                                @replayParsed.startTime.getOrElse("Unknown")
                            </td>
                            }
                            case Some(ImpossibleToParse) | None => {
                            <td>?</td>
                            <td>?</td>
                            <td>?</td>
                            <td>?</td>
                            }
                            }
                        </tr>
                        }
                        </tbody>
                    </table>
                </div>
            </details>
            }

            @if(uploadSession.failedFiles.nonEmpty) {
            <details open>
                <summary>@messages("upload.failed.files", uploadSession.failedFiles.length.toString)</summary>
                <div class="table-container">
                    <table>
                        <thead>
                        <tr>
                            <th>@messages("upload.table.filename")</th>
                            <th>@messages("upload.table.error")</th>
                        </tr>
                        </thead>
                        <tbody>
                        @for(file <- uploadSession.failedFiles) {
                        <tr>
                            <td>@file.fileName</td>
                            <td>@file.errorMessage.getOrElse(messages("upload.unknown.error"))</td>
                        </tr>
                        }
                        </tbody>
                    </table>
                </div>
            </details>
            }
        </article>
    </section>

    @if(uploadSession.successfulFiles.nonEmpty) {
    <!-- Match Winner Form Section -->

    <section>
        <article>
            <header>
                <h3>@messages("upload.match.result")</h3>
            </header>
            <form id="match_result_form" method="post"
                  action="@routes.MatchResultController.submitResult(tournamentID, matchID)">
                @helper.CSRF.formField

                <fieldset>
                    <legend>@messages("upload.select.outcome")</legend>
                    <label>
                        <input type="radio" name="selection" value="@firstUser.get.userId"
                               onclick="updateHiddenFields('@firstUser.get.userId', 'with_winner')" required/>
                        @firstUser.get.userName
                    </label>
                    <label>
                        <input type="radio" name="selection" value="@secondUser.get.userId"
                               onclick="updateHiddenFields('@secondUser.get.userId', 'with_winner')"/>
                        @secondUser.get.userName
                    </label>
                    <label>
                        <input type="radio" name="selection" value="tie" onclick="updateHiddenFields(null, 'tie')"/>
                        @messages("upload.tie")
                    </label>
                    <label>
                        <input type="radio" name="selection" value="cancelled"
                               onclick="updateHiddenFields(null, 'cancelled')"/>
                        @messages("upload.cancelled")
                    </label>
                </fieldset>

                <fieldset id="smurf-selection-fieldset">
                    <legend>@messages("upload.select.smurfs")</legend>
                    <div class="grid">
                        <div>
                            <label for="in_game_smurf_first">@messages("upload.smurf.first",
                                firstUser.get.userName)</label>
                            <select name="in_game_smurf_first" id="in_game_smurf_first"
                                    onchange="updateSmurfSelection('first')" disabled>
                                <option value="">@messages("upload.select.smurf")</option>
                            </select>
                        </div>
                        <div>
                            <label for="in_game_smurf_second">@messages("upload.smurf.second",
                                secondUser.get.userName)</label>
                            <select name="in_game_smurf_second" id="in_game_smurf_second"
                                    onchange="updateSmurfSelection('second')" disabled>
                                <option value="">@messages("upload.select.smurf")</option>
                            </select>
                        </div>
                    </div>
                    <small>@messages("upload.smurf.help")</small>
                </fieldset>

                <input type="hidden" name="winnerId" id="winnerIdField"/>
                <input type="hidden" name="resultType" id="resultTypeField"/>

                <button type="submit" id="submit-result-btn" disabled>@messages("upload.submit.result")</button>


            </form>

        </article>
    </section>
    }


    }


    <!-- Upload Form Section -->
    <section>
        <article>
            <header>
                <h3>@if(uploadSession.hasFiles) {@messages("upload.add.more.files")} else
                    {@messages("upload.select.files")}</h3>
            </header>

            <div id="validation-flash" style="display: none;">
                <h4>@messages("upload.validation.problems")</h4>
                <div id="validation-messages"></div>
            </div>

            <form id="upload-form" enctype="multipart/form-data" method="post"
                  action="@routes.FileUploadController.uploadFile(tournamentID, matchID)">
                @helper.CSRF.formField
                <div id="file-input-container">
                    <input
                            id="uploadFileInput"
                            type="file"
                            name="upload_file"
                            accept=".rep"
                            multiple
                    />
                    <small>@messages("upload.max.size")</small>
                </div>

                <div id="file-info" style="display: none;">
                    <strong>@messages("upload.selected.files")</strong> <span id="selected-files-count">0</span> <span
                        id="files-text">@messages("upload.files.count", "0").split(" ")(1)</span>
                </div>

                <button type="submit" id="submit-btn" style="display: none;">
                    @messages("upload.upload.files")
                </button>
            </form>
        </article>
    </section>

    @if(errorMessage.isDefined) {
    <section>
        <article>
            <h3>@messages("upload.error.title")</h3>
            <p>@errorMessage.get</p>
            <a href="/upload" role="button" class="secondary">@messages("upload.try.again")</a>
        </article>
    </section>
    }
</div>

<script>
    // Global variables to store replay data and smurfs
    let replaySmurfs = new Set();
    let smurfPairs = [];

    // Internationalized messages for JavaScript
    const i18nMessages = {
        unknownPlayer: '@Html(messages("upload.js.unknown.player"))',
        selectSmurf: '@Html(messages("upload.select.smurf"))',
        extensionError: '@Html(messages("upload.js.extension.error"))',
        sizeError: '@Html(messages("upload.js.size.error"))'
    };

    function updateHiddenFields(winnerId, resultType) {
        document.getElementById('resultTypeField').value = resultType;
        document.getElementById('winnerIdField').value = winnerId;
        checkFormValidity();
    }

    function extractSmurfsFromReplays() {
        // Clear previous data
        replaySmurfs.clear();
        smurfPairs = [];

        // Get all successful files and extract smurfs
        const rows = document.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const cells = row.children;
            if (cells.length >= 3) {
                // Extract player names from the table cells (removing race info)
                const player1Text = cells[1].textContent.trim();
                const player2Text = cells[2].textContent.trim();
                
                // Extract just the name part (before the race indicator in parentheses)
                const player1Name = player1Text.split('(')[0].trim();
                const player2Name = player2Text.split('(')[0].trim();
                
                if (player1Name && player1Name !== i18nMessages.unknownPlayer) {
                    replaySmurfs.add(player1Name);
                }
                if (player2Name && player2Name !== i18nMessages.unknownPlayer) {
                    replaySmurfs.add(player2Name);
                }
                
                // Store the pair for later use
                if (player1Name && player2Name && 
                    player1Name !== i18nMessages.unknownPlayer && player2Name !== i18nMessages.unknownPlayer) {
                    smurfPairs.push({
                        player1: player1Name,
                        player2: player2Name
                    });
                }
            }
        });

        populateSmurfSelectors();
    }

    function populateSmurfSelectors() {
        const firstSelect = document.getElementById('in_game_smurf_first');
        const secondSelect = document.getElementById('in_game_smurf_second');
        
        // Clear existing options (keep the first default option)
        firstSelect.innerHTML = `<option value="">${i18nMessages.selectSmurf}</option>`;
        secondSelect.innerHTML = `<option value="">${i18nMessages.selectSmurf}</option>`;

        // Add all unique smurfs to both selectors
        Array.from(replaySmurfs).sort().forEach(smurf => {
            const option1 = document.createElement('option');
            option1.value = smurf;
            option1.textContent = smurf;
            firstSelect.appendChild(option1);

            const option2 = document.createElement('option');
            option2.value = smurf;
            option2.textContent = smurf;
            secondSelect.appendChild(option2);
        });

        // Enable the selectors if we have smurfs
        if (replaySmurfs.size > 0) {
            firstSelect.disabled = false;
            secondSelect.disabled = false;
        }
    }

    function updateSmurfSelection(selectedPlayer) {
        const firstSelect = document.getElementById('in_game_smurf_first');
        const secondSelect = document.getElementById('in_game_smurf_second');
        
        let selectedSmurf, otherSelect;
        
        if (selectedPlayer === 'first') {
            selectedSmurf = firstSelect.value;
            otherSelect = secondSelect;
        } else {
            selectedSmurf = secondSelect.value;
            otherSelect = firstSelect;
        }

        if (selectedSmurf) {
            // Find the corresponding smurf from replay pairs
            const matchingPair = smurfPairs.find(pair => 
                pair.player1 === selectedSmurf || pair.player2 === selectedSmurf
            );
            
            if (matchingPair) {
                const otherSmurf = matchingPair.player1 === selectedSmurf ? 
                    matchingPair.player2 : matchingPair.player1;
                
                // Set the other selector to the paired smurf but keep it enabled
                otherSelect.value = otherSmurf;
                // Don't disable the other selector so it gets submitted with the form
                otherSelect.disabled = false;
            } else {
                // If no pair found, clear the other selector but keep it enabled
                otherSelect.value = '';
                otherSelect.disabled = false;
            }
        } else {
            // If no smurf selected, re-enable the other selector and clear its value
            otherSelect.disabled = false;
            otherSelect.value = '';
        }
        
        checkFormValidity();
    }

    function checkFormValidity() {
        const firstSmurfSelect = document.getElementById('in_game_smurf_first');
        const secondSmurfSelect = document.getElementById('in_game_smurf_second');
        const resultTypeField = document.getElementById('resultTypeField');
        const submitBtn = document.getElementById('submit-result-btn');
        
        // Check if result type is selected and both smurfs are selected
        const hasResultType = resultTypeField && resultTypeField.value;
        const hasFirstSmurf = firstSmurfSelect.value;
        const hasSecondSmurf = secondSmurfSelect.value;
        
        // Enable submit button only if result type and both smurfs are selected
        if (hasResultType && hasFirstSmurf && hasSecondSmurf) {
            submitBtn.disabled = false;
        } else {
            submitBtn.disabled = true;
        }
    }

    // Initialize smurf extraction when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Only extract smurfs if we have successful files
        if (document.querySelector('tbody tr')) {
            extractSmurfsFromReplays();
        }
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const uploadFileInput = document.getElementById('uploadFileInput');
        const uploadForm = document.getElementById('upload-form');
        const fileInfo = document.getElementById('file-info');
        const selectedFilesCount = document.getElementById('selected-files-count');
        const validationFlash = document.getElementById('validation-flash');
        const validationMessages = document.getElementById('validation-messages');
        const submitBtn = document.getElementById('submit-btn');

        let validationResults = [];

        uploadFileInput.addEventListener('change', function(event) {
            const files = event.target.files;

            if (files.length === 0) {
                fileInfo.style.display = 'none';
                validationFlash.style.display = 'none';
                return;
            }

            // Show file info
            fileInfo.style.display = 'block';
            selectedFilesCount.textContent = files.length;

            // Validate files
            validationResults = validateFiles(files);

            // Check if all files are valid
            const hasErrors = validationResults.some(result => result.errors.length > 0);

            if (hasErrors) {
                showValidationErrors(validationResults);
            } else {
                validationFlash.style.display = 'none';
                // Auto-submit when all files are valid
                uploadForm.submit();
            }
        });

        function validateFiles(files) {
            const results = [];
            const maxSizeBytes = 1 * 1024 * 1024; // 1MB

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const errors = [];

                // Check file extension
                if (!file.name.toLowerCase().endsWith('.rep')) {
                    errors.push(i18nMessages.extensionError);
                }

                // Check file size
                if (file.size > maxSizeBytes) {
                    const sizeInMB = (file.size / (1024 * 1024)).toFixed(2);
                    errors.push(i18nMessages.sizeError.replace('{0}', sizeInMB));
                }

                results.push({
                    fileName: file.name,
                    errors: errors
                });
            }

            return results;
        }

        function showValidationErrors(results) {
            const errorsExist = results.some(result => result.errors.length > 0);

            if (!errorsExist) {
                validationFlash.style.display = 'none';
                return;
            }

            // Clear previous messages
            validationMessages.innerHTML = '';

            // Create flash messages for each file with errors
            results.forEach(result => {
                if (result.errors.length > 0) {
                    result.errors.forEach(error => {
                        const flashCard = document.createElement('div');
                        flashCard.innerHTML = `
                            <strong>${escapeHtml(result.fileName)}:</strong> ${escapeHtml(error)}
                        `;
                        validationMessages.appendChild(flashCard);
                    });
                }
            });

            validationFlash.style.display = 'block';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    });
</script>
}